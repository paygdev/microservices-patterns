# 3장. 프로세스 간 통신

> REST, 메시징등 다양한 IPC 옵션과 트레이드 오프에 대한 설명
필자는 메시징으로 느슨한 결합을 선호
> 

# 3.1 마이크로서비스 아키텍처 IPC 개요

- 서비스에 적용할 IPC 기술은 **선택의 폭이 넓다**
- HTTP 기반, 비동기 메시지 기반 등

## 3.1.1 상호 작용 스타일

- 클라이언트 / 서비스 간 상호 작용 스타일을 잘 살펴보면, 특정 IPC 기술의 세부 내용에 빠져 헤매는 일 방지
- 전체 애플리케이션의 가용성의 영향 및 통합 테스트 전략을 수립하는 데 도움
- 두가지 기준으로 분류
    1. 일대일 일대다
    2. 동기 비동기
- **일대일** 상호 작용 종류
    - 동기 요청/응답
        - 주로 IPC 기술에 직교적(서로 연관성 없이 독립적)인 상호 작용 스타일
    - 비동기 요청/응답
    - 단방향 알림
- **일대다** 상호 작용 종류
    - 발행/구독
    - 발행/비동기 응답
- 각 서비스마다 상호 작용 스타일을 조합해서 사용

## 3.1.2 마이크로서비스 API 정의

- API와 인터페이스는 소프트웨어 개발의 핵심
- 모듈마다 클라이언트가 호출하는 작업이 정의된 인터페이스가 존재
- 잘 설계된 인터페이스는 유용한 기능은 표출, 구현체는 감추어져 있어 클라이언트에 영향을 미치지 않고 코드를 고칠 수 있음
- 마이크로서비스 아키텍처에서는 **API와 인터페이스가 똑같이 중요**
- 정의상 클라이언트와 서비스는 함께 컴파일 되지 않으므로 서로 맞지 않을 수 있음
- 어떤 IPC를 선택하든, 서비스 API를 IDL(Interface Definition Language)로 정확하게 정의
- 선 설계 후, 구현 방식으로 진행하면 클라이언트 니즈에 좀 더 부합한 서비스를 구축할 수 있음

## 3.1.3 API 발전시키기

- API는 계속해서 기존 기능을 추가하거나 삭제하며 바뀜
- 모놀리식은 여러 곳에서 사용하는 API를 고치는 일은 **변경 범위가 문제**
- 마이크로서비스는 다른 팀의 서비스일 경우가 대다수라 **API를 변경하는 것 자체가 어려움**

### **시맨틱 버저닝**

- 시맨틱 버저닝 명세는 API 버저닝에 관한 유용한 지침서
- 원래 소프트웨어 패키지의 버저닝 용도로 쓰였지만, 분산 시스템의 API 버저닝에도 사용할 수 있음
- 명세에 따르면 버전 번호를 MAJOR.MINOR.PATCH 세 파트로 구성
    - MAJOR : 하위 호환되지 않는 변경분을 API에 적용
    - MINOR : 하위 호환되는 변경분을 API 적용
    - PATCH : 하위 호환되는 오류 수정
- REST API는 메이저 버전을 URL 경로의 첫번째 엘리먼트, 메시징 기반은 발행한 메시지에 버전 번호

### **하위 호환되는 소규모 변경**

- 가급적 하위 호환성을 보장하는 방향으로 변경
- 견고성의 원칙을 지킬 것 (당신이 하는 일은 보수적으로, 다른 사람들이 하는 일은 관대하게 바라보라)

### **중대한 대규모 변경**

- 일시적으로 클라이언트를 강제로 업그레이드는 불가하므로 일정 기간 동안 신/구 API 모두 지원
- HTTP 기반은 URL에 삽입( /v1, /v2)
- HTTP 컨텐트 협상을 이용하여 MIME 타입 내부에 버전 번호 끼워 넣기

## 3.1.4 메시지 포맷

- IPC 핵심은 메시지 교환, 메시지는 데이터를 담고 있으므로 데이터 포맷은 중요한 설계 결정 항목
- 또, IPC의 효율, API 사용성, 발전성에도 영향을 미침
- 다른 언어를 사용하여 서비스를 만들 수 있으므로 범언어적 메시지 포맷을 선택하는 것이 좋음(자바 직렬화X)
- 텍스트 메시지 포맷
    - JSON, XML 등 텍스트 기반 포맷을 사람이 읽을 수 있고 자기 서술적 장점
    - 메시지 컨슈머는 자신이 관심 있는 값만 골라 쓰고 나머지는 무시해도 되므로 하위 호환성이 쉽게 보장
    - 문서 구조는 XML은 스키마, JSON도 필요하여 스키마 표준이 제정
    - 메시지 길이가 다소 긴 것이 단점, 효율/성능이 중요하다면 이진 포맷을 고려
- 이진 메시지 포맷
    - 프로토컬 버퍼(구글)와 아브로(아파치)가 유명
    - 구조 정의에 필요한 타입 IDL 제공 및 컴파일러는 직렬화/역직렬화하는 코드를 생성
    - 서비스를 API 우선 접근 방식으로 설계할 수 밖에 없음
        
        [API 우선 접근 방식과 OpenAPI Specification](https://forward.nhn.com/2022/sessions/18)
        
    - 정적 타입 언어로 클라이언트를 작성할 경우, 클라이언트가 API를 올바르게 사용하고 있는지 컴파일러로 확인 가능
    - 스리프트, 프로토콜 버퍼, 아브로 비교 분석 글
        
        [Schema evolution in Avro, Protocol Buffers and Thrift](https://martin.kleppmann.com/2012/12/05/schema-evolution-in-avro-protocol-buffers-thrift.html)
        

# 3.2 동기 RPI 패턴 응용 통신

- RPI(Remote Procedure Invocation)는 클라이언트가 서비스에 요청을 보내면 서비스가 처리 후 응답을 회신하는 IPC
- 블로킹/논블로킹 클라이언트들 모두 응답이 제때 도착하리라 가정
- RPI 작동 원리
    
    ![Untitled](3%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%20%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%90%E1%85%A9%E1%86%BC%E1%84%89%E1%85%B5%E1%86%AB%2094428438f3854bc9a0b4025c9c244aa8/Untitled.png)
    
- 프록시 인터페이스는 하부 통신 프로토콜을 캡슐화

## 3.2.1 동기 RPI 패턴: REST

- REST는 **거의 항상** HTTP로 소통하는 IPC
- 리소스는 REST의 핵심
- HTTP 동사를 사용하여 URL로 참조되는 리소스를 가공(GET, POST, PUT)

### **REST 성숙도 모델**

- 레너드 리처드슨이 유용한 모델을 제시(4단계)
    - 레벨 0
        
        > 클라이언트는 서비스의 URL 끝점에 HTTP POST 요청하여 서비스 호출
        요청 할 때마다 어떤 액션을 수행할지, 그 대상은 무엇인지 지정, 필요 매개변수 전달
        > 
    - 레벨 1
        
        > 서비스는 리소스 개념 지원
        클라이언트는 수행할 액션과 매개변수가 지정된 POST요청
        > 
    - 레벨 2
        
        > 서비스는 HTTP 동사(메소드?)를 이용하여 액션을 수행
        요청 쿼리 매개변수 및 본문 필요 시 매개변수 지정
        GET 요청을 캐싱하는 등 웹 인프라를 활용 가능
        > 
    - 레벨 3
        
        > 서비스를 HATEOAS 원칙에 기반하여 설계
        (GET 요청으로 주문 데이터 조회, 이 때 반환된 표현형 내부 링크를 통해 해당 주문 취소가 가능)
        > 

### **REST API**

- REST에는 IDL이 없었으나, 필요성을 느끼고 스웨거라는 오픈 소스 프로젝트로 발전

### **요청 한 번으로 많은 리소스를 가져오기 어렵다**

- 연관된 리소스가 있을 때, 모두 가져올 수 있을지 고민하게 됨
- 이 방법을 해결하기 위해서는 리소스를 획득할 때 연관된 리소스도 함께 조회하도록 API가 허락
GET /oders/oder-id-1234?expand=consumer
- 하지만 시나리오가 복잡할 수록 효율이 떨어지고 구현 시간이 많이 듬
- 데이터를 효율적으로 조회할 수 있도록 설계된 GraphQL, 넷플릭스 팔코등 대체 API 기술 각광

### **작업을 HTTP 메소드에 매핑하기 어렵다**

- 메소드가 너무 포괄적이라 표현하기가 어려움
- 한 가지 해결방법은 리소스의 특정 부위를 업데이트하는 하위 리소스를 정의
- 주문 취소 : POST /orders/{orderId}/cancel
주문 변경 : POST /oders/{oderId}/revise
- 동사를 URL 쿼리 매개변수로 지정하는 방법도 있지만 REST 답지 않아 gRPC 같은 REST 대체 기술이 점점 인기를 끄는 추세

### **REST의 장단점**

- 장점
    - 단순, 익숙
    - 포스트맨 같은 브라우저 플러그인, curl 등의 CLI 도구 사용하여 간편하게 테스트
    - 요청/응답 스타일의 통신을 직접 지원
    - HTTP는 방화벽 친화적
    - 중간 브로커가 필요하지 않아 시스템 아키텍처가 단순
- 단점
    - 요청/응답 스타일의 통신만 지원
    - 가용성 떨어짐 (중간 매개자가 없음)
    - 서비스 인스터스의 위치(URL)을 클라이언트가 알고 있어야 함(서비스 디스커버리 메커니즘이 있어 큰 단점 X)
    - 요청 한번으로 여러 리소스 가져오기 어려움
    - 다중 업데이트 작업을 HTTP 메소드에 매핑하기 어려움
- REST는 API의 표준이지만 흥미로운 대체 기술들이 많아짐(GraphQL, gRPC)

## 3.2.2 동기 RPI 패턴: gRPC

- HTTP의 한정된 메소드만 지원하는 단점을 보완하기 위해 나옴
- gRPC는 다양한 언어로 클라이언트/서버를 작성할 수 있는 프레임워크
- 이진 메시지 기반 프로토콜
- 프로토콜 버퍼 기반의 IDL로 정의, 컴파일러로 클라이언트 쪽 스텁 및 서버쪽 스켈레톤을 생성 가능
(자바, C#, Node.js, Go 등 다양한 언어의 코드 생성)
- 클라이언트/서버는 프로토콜 버퍼 포맷의 이진 메시지를 HTTP/2를 통해 교환
- 하나 이상의 서비스와 요청/응답 메시지 데피니션으로 구성
- 단순 요청/응답 RPC는 물론 스트리밍 RPC도 지원(메시지 스트림)
- 프로토콜 버퍼 메시지는 각 필드마다 번호가 매겨지고 타입 코드가 할당
- 수신자는 자신이 필요한 필드만 추출하고 그냥 건너뜀이 가능하여 하위 호환성이 좋음
- 장점
    - 다양한 업데이트 작업이 포함된 API를 설계하기 쉬움
    - 큰 메시지를 교환할 때 효율적
    - 양방향 스트리밍 덕분에 RPI, 메시징 두 가지 통신 방식
    - 다양한 언어로 작성된 클라이언트/서버 간 연동 가능
- 단점
    - JS 클라이언트가 하는 일이 REST/JSON 기반 API보다 많음
    - 구형 방화벽은 HTTP/2를 지원하지 않음

### 부분 실패 처리: 회로 차단기 패턴

- 분산 시스템은 서비스가 다른 서비스를 동기 호출할 때마다 부분 실패할 가능성이 항상 존재
- 클라이언트는 응답 대기 도중 블로킹이 되어 전체 시스템을 마비시키는 위험 초래
- 부분 실패가 애플리케이션 전체에 전파되지 않도록 서비스 설계
- 솔루션
    - 무응답 원격 서비스를 처리하기위해 견고한 RPI 프록시 설계
    - 원격 서비스가 실패하면 어떻게 조치해야 할지 결정

### **견고한 RPI 프록시 설계**

- 넷플릭스 기술 블로그, 서비스가 다른 서비스를 동기 호출할 때 자기 스스로를 방어하는 방법이 명쾌하게 기술
    
    [Fault Tolerance in a High Volume, Distributed System](https://netflixtechblog.com/fault-tolerance-in-a-high-volume-distributed-system-91ab4faae74a)
    
- 네트워크 타임아웃
    - 항상 타임아웃을 걸어 두기
- 미처리 요청 개수 제한
    - 특정 서비스에 요청 가능한 미처리 요청의 최대 개수를 설정
    - 이 이상이 넘어가면 요청이 무의미하므로 바로 실패
- 회로 차단기 패턴(서킷 브레이커)
    - 에러율이 임계치를 넘었을 경우 바로 실패 처리
    - 만약 클라이언트가 다시 시도하여 성공하면 회로 차단기는 닫힘
- 넷플릭스 히스트릭스는 이와 같이 다양한 패턴이 구현된 오픈 소스 라이브러리

### **불능 서비스 복구**

- 무응답 원격 서비스를 어떻게 구하면 좋을지는 그때그때 상황에 맞게 판단
- 클라이언트가 알기 쉽게 에러를 반환하는 것도 괜찮
- 부분 실패 시 미리 정해진 기본 값이나 캐시된 응답 값으로 대체하는 방법도 존재
    
    ![Untitled](3%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%20%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%90%E1%85%A9%E1%86%BC%E1%84%89%E1%85%B5%E1%86%AB%2094428438f3854bc9a0b4025c9c244aa8/Untitled%201.png)
    
    - 모든 서비스가 똑같이 중요하지 않음
    - API 게이트웨가 캐시된 버전의 데이터를 반환하거나 아예 해당 데이터를 응답에서 제거해도 됨

## 3.2.4 서비스 디스커버리

- 서비스를 호출하기 위해서는 네트워크 위치(IP, Port)를 알고 있어야 함
- 물리 서버의 경우 정적이라 쉽지만, 클라우드 기반의 서버는 동적이라 쉽지 않음
- 여러가지 사유로 위치가 계속 달라지므로 클라이언트 코드는 서비스 디스커버리를 사용할 수 밖에 없음

### **서비스 디스커버리 개요**

- 애플리케이션 서비스 인스턴스의 네트워크 위치를 DB화한 서비스 레지스트리가 핵심
- 서비스 인스턴스가 시작/종료할 때마다 서비스 레지스트리가 업데이트
- 클라이언트가 요청 시 서비스 레지스트리에서 목록을 가져와 요청 라우팅
- 구현
    - 클라이언트/서비스가 직접 서비스 레지스트리와 상호 작용
    - 배포 인프라로 서비스 디스커버리를 처리(12장에서 다룸)

### **애플리케이션 수준의 서비스 디스커버리 패턴 적용**

![Untitled](3%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%20%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%90%E1%85%A9%E1%86%BC%E1%84%89%E1%85%B5%E1%86%AB%2094428438f3854bc9a0b4025c9c244aa8/Untitled%202.png)

- 애플리케이션 클라이언트/서비스가 직접 서비스 레지스트리와 통신
- 서비스는 자기 위치를 등록, 클라이언트는 서비스 레지스트리에서 받아와 요청
- 두 가지 패턴을 조합한 서비스 디스커버리 방식
    - 자가 등록 패턴(서비스쪽)
        - 자신의 네트워크 위치를 서비스 레지스트리 등록 API 호출
        - 헬스 체크 URL을 제공하는 서비스도 존재
        - 이전에 등록한 네트워크 위치가 만료되지 않도록 주기적으로 하트비트 API 호출
    - 클라이언트쪽 디스커버리 패턴
        - 서비스 호출할 때, 먼저 서비스 레지스트리에 서비스 인스턴스 목록을 요청하여 넘겨 받음
        - 라운드 로빈 혹은 랜덤 같은 부하 분산 알고리즘을 이요하여 서비스 인스턴스를 선택한 후 요청 전송
- 넷플릭스(유레카)와 피보탈(스프링 클라우드) 덕분에 대중화
- 다양한 플랫폼에서 배포된 경우에도 처리 가능
- 언어 혹은 프레임워크에 맞는 서비스 디스커버리 라이브러리가 필요함
- 서비스 레지스트리를 직접 설정/관리하는 업무가 가중되는 부담

### **플랫폼에 내장된 서비스 디스커버리 패턴 적용**

- 도커, K8S등 최신 배포 플랫폼에는 대부분 서비스 레지스트리, 서비스 디스커버리 매커니즘 탑재
- 클라이언트가 DNS명/VIP를 요청, 배포 플랫폼이 알아서 가용 서비스 인스턴스로 라우팅

![Untitled](3%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%20%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%90%E1%85%A9%E1%86%BC%E1%84%89%E1%85%B5%E1%86%AB%2094428438f3854bc9a0b4025c9c244aa8/Untitled%203.png)

- 이는 두 패턴을 접목
    - 서드파티 등록 패턴
        - 서비스가 직접 등록하는 것이 아닌 플랫폼의 일부인 등록기가 대행
    - 서버 쪽 디스커버리 패턴
        - 클라이언트가 서비스 레지스트리를 질의하지 않고 DNS명을 요청
        - 라우터가 레지스트리로 쿼리하고 부하 분산
- 플랫폼에서 제공된 서비스 디스커버리는 편리, 서비스 개발 언어와도 상관 없음
- 한 플랫폼에서 제공되는 서비스 디스커버리를 사용할 것을 권장

# 3.3 비동기 메시징 패턴 응용 통신

- 메시징은 서비스가 메시지를 서로 비동기적으로 주고받는 통신 방식
- 보통 서비스 간 중개 역할을 하는 메시지 브로커를 사용하나 직접 통신하는 브로커리스 아키텍처도 존재
- 클라이언트는 응답을 바로 받지 못할 것을 가정

## 3.3.1 메시징 개요

- 메시징 모델은 메시지 채널이라는 곳을 통해 메시지를 주고 받음

### 메시지

- 헤더(메타 데이터), 본문으로 구성
- 본문은 실제로 송신할 텍스트 또는 이진 포맷의 데이터
- 종류
    - 문서 : 데이터만 포함된 제네릭한 메시지, 해석은 수신자가 결정
    - 커맨드 : RPC 요청과 동등한 메시지, 호출할 작업과 전달할 매개변수가 지정
    - 이벤트 : 송신자에게 어떤 사건이 발생했음을 알리는 메시지, 대부분 도메인 객체의 상태를 나타내는 도메인 이벤트

### 메시지 채널

![Untitled](3%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%20%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%90%E1%85%A9%E1%86%BC%E1%84%89%E1%85%B5%E1%86%AB%2094428438f3854bc9a0b4025c9c244aa8/Untitled%204.png)

- 송신자의 비즈니스 로직은 하부 통신 메커니즘을 캡슐화한 송신 포트 인터페이스를 호출
- 송신자 어댑터 클래스가 이를 구현, 메시지 채널을 통해 수신자에게 전달
- 수신자의 메시지 핸들러 어댑터 클래스는 메시지를 처리하기 위해 호출 됨
- 해당 클래스는 수신 포트 인터페이스를 호출
- 보낼 수 있는 메시지와 수신자가 채널에서 받을 수 있는 메시지의 개수는 무제한
- 종류
    - 점대점 채널
        - 채널을 읽는 컨슈머 중 딱 하나만 지정하여 메시지 전달
    - 발행-구독 채널
        - 같은 채널을 바라보는 모든 컨슈머에게 메시지를 전달

## 3.2.2 메시징 상호 작용 스타일 구현

### 요청/응답 및 비동기 요청/응답

- 메시징은 원래 성격 자체가 비동기적이라 비동기 요청/응답만 제공하지만 응답을 수신할 때까지 블로킹 가능
- 클라이언트/서비스는 한 쌍의 메시지를 주고받는 비동기 요청/응답 스타일로 상호 작용

![Untitled](3%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%20%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%90%E1%85%A9%E1%86%BC%E1%84%89%E1%85%B5%E1%86%AB%2094428438f3854bc9a0b4025c9c244aa8/Untitled%205.png)

- 클라이언트는 서비스가 어디로 요청을 보내야 하는지 알려주고 응답 메시지와 요청 메시지는 짝이 맞아야 함
- 짝을 맞추는 일은 요청과 응답의 메시지 ID를 넣으면 쉽게 해결

### 단방향 알림

- 비동기 메시징을 이용하여 직관적으로 구현
- 서비스가 소유한 메시지 채널로 메시지를 보내면 서비스가 구독하여 메시지를 처리하는 구조
- 응답 반환 X

### 발행/구독

- 메시징은 발행/구독 스타일의 상호 작용을 기본으로 지원

### 발행/비동기 응답

- 발행/구독과 요청/응답의 엘리먼트를 조합한 고수준의 상호 작용 스타일
- 클라이언트 응답 채널 헤더가 명시된 메시지를 발행/구독 채널에 발행, 컨슈머는 메시지ID를 작성하여 지정된 응답 채널에 발행, 클라이언트는 이를 보고 요청과 응답을 맞추어 봄

## 3.3.3 메시징 기반 서비스의 API 명세 작성

- API 명세에는 메시지 채널명, 각 채널을 통해 교환되는 메시지 타입과 포맷을 명시
- 포맷을 JSON, XML, 프로토콜 버퍼 등 표준 포맷으로 기술
- REST, 오픈 API와 달리 채널 및 메시지 타입은 딱히 정해진 문서화 표준이 없으므로 자유롭게 기술
- 서비스 비동기 API는 클라이언트가 호출하는 **작업**과 서비스에 의해 발행되는 **이벤트**로 구성

![Untitled](3%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%20%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%90%E1%85%A9%E1%86%BC%E1%84%89%E1%85%B5%E1%86%AB%2094428438f3854bc9a0b4025c9c244aa8/Untitled%206.png)

### 비동기 작업 문서화

- 서비스 작업은 두 가지 상호 작용 스타일로 호출
    - 요청/비동기 응답 스타일 API
        - 커맨드 메시지 채널, 커맨드 메시지 타입과 포맷, 응답 메시지 타입과 포맷
    - 단방향 알림 스타일 API
        - 커맨드 메시지 채널, 커맨드 메시지의 타입과 포맷

### 발행 이벤트 문서화

- 발행/구독 스타일로도 이벤트 발행 가능
- 이벤트 채널, 인벤트 메시지의 타입과 포맷으로 구성

## 3.3.4 메시지 브로커

- 메시징 기반의 애플리케이션은 대부분 메시지 브로커를 사용
- 브로커는 서비스가 서로 통신할 수 있게 해주는 인프라 서비스

### 브로커리스 메시징

- 메시지를 서로 직접 교환
- ZeroMQ는 잘 알려진 브로커리스 메시징 기술
- 장점
    - 직접 전달로 네트워크 트래픽이 가볍고 지연 시간이 짧음
    - 브로커가 성능 병목점 혹은 SPOF(단일 장애점)가 될 일이 없음
    - 운영 복잡도가 낮음
- 단점
    - 서비스의 위치를 알고 있어야하므로 서비스 디스커버리 메커니즘 사용
    - 메시지 교환 시 송/수신자 모두 실행 중이어야 하므로 가용성이 떨어짐
    - 전달 보장 같은 메커니즘을 구현하기가 더 어려움

### 브로커 기반 메시징 개요

- 송신자가 메시지 브로커에 메시지를 쓰면 메시지 브로커는 수신자에 전달
- 송신자는 수신자의 위치를 몰라도 됨
- 컨슈머가 메시지를 처리할 수 있을 때까지 메시지를 버퍼링할 수 있음
- 브로커 종류
    - ActiveMQ
    - RabbitMQ
    - 아파치 카프카
    - AWS 키네시스 - 클라우드 기반
    - AWS SQS(Simple Queue Serivce) - 클라우드 기반
- 선택할 때 검토할 것들
    - 프로그래밍 언어 지원 여부 → 다양한 언어를 사용할 수록 좋음
    - 메시징 표준 지원 여부 → 표준 프로토콜을 지원하는 제품인가, 자체 표준만 지원하는 제품인가
    - 메시지 순서 → 메시지 순서가 유지 되는가?
    - 전달 보장 → 어떤 종류의 전달 보장을 하는가?
    - 영속화 → 고장이 나도 문제 없이 메시지를 디스크에 저장하는가?
    - 내구성 → 컨슈머가 브로커에 접속 시, 중단된 시간에 이어서 받을 수 있는가?
    - 확장성
    - 지연 시간 → 종단 간 지연 시간은 얼마나 되나?
    - 경쟁사 컨슈머
- 브로커마다 다 일장일단이 존재
- 메시징 순서 유지 및 확장성은 필수 요건

### 메시지 브로커로 메시지 채널 구현

| 메시지 브로커 | 점대점 채널 | 발행-구독 채널 |
| --- | --- | --- |
| JMS | 큐 | 토픽 |
| Apache Kafka | 토픽 | 토픽 |
| AMQP 브로커 | 익스체인지 + 큐 | 팬아웃 익스체인지, 컨슈머 개별 큐 |
| AWS 키네시스 | 스트림 | 스트림 |
| AWS SQS | 큐 | - |

### 브로커 기반 메시징의 장단점

- 장점
    - 느슨한 결합
        - 클라이언트는 적절한 채널에 메시지를 보내는 형식
        - 디스커버리 메커니즘 필요가 없음
    - 메시지 버퍼링
        - 메시지 브로커는 처리 가능한 시점까지 메시지를 버퍼링
        - 수신자 시스템이 느려지거나 불능 상태에 빠져도 송신자는 계속해서 메시징을 보낼 수 있음
    - 유연한 통신
        - 모든 상호 작용 스타일을 지원
    - 명시적 IPC
        - ?
- 단점
    - 성능 병목 가능성
        - 다행히 요즘 메시지 브로커는 확장이 잘 되도록 설계
    - 단일 장애점 가능성
        - 다행히 요즘 브로커는 고가용성이 보장 되도록 설계
    - 운영 복잡도 부가

## 3.3.5 수신자 경합과 메시지 순서 유지

- 다수의 스레드와 서비스 인스턴스를 사용한다면 메시지 순서가 중요
- 아파치 카프카, AWS 키네시스 등 요즘 메시지 브로커는 샤딩된 채널을 이용
- 다음 세 부분으로 구성
    - 샤딩된 채널은 복수의 샤드로 구성, 각 샤드는 채널처럼 작동
    - 송신자는 메시지 헤더에 샤드 키를 지정
    메시지 브로커는 메시지를 샤드 키별로 샤드/파티젼에 배정
    - 메시징 브로커는 여러 수신자 인스턴스를 묶어 마치 동일한 논리 수신자처럼 취급
    (아파치 카프카 용어로 이를 컨슈머 그룹이라고 함)
    메시지 브로커는 각 샤드를 하나의 수신자에 배정
    수신자가 시동/종료하면 샤드를 재배정
    
    ![Untitled](3%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%20%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%90%E1%85%A9%E1%86%BC%E1%84%89%E1%85%B5%E1%86%AB%2094428438f3854bc9a0b4025c9c244aa8/Untitled%207.png)
    
    - 주문별 이벤트는 orderId로 구분, 주문별로 이벤트가 동일한 샤드에 발행되고 이를 어느 한 컨슈머에서만 읽기 때문에 순서 보장

## 3.3.6 중복 메시지 처리

- 메시지 브로커가 각 메시지를 꼭 한번만 전달하기 위해서는 값비싼 대가를 치뤄야 함
- 그래서 브로커는 적어도 한 번 이상 메세지를 전달하겠노라 약속
- 메시지 브로커가 메시지를 재전송할 때 순서까지 유지하면 이상적
- 중복 메시지를 처리하는 두 가지 방법
    - 멱등한 메시지 핸들러를 작성
    - 메시지를 추적하고 중복을 솎아 냄

### 멱등한 메시지 핸들러 작성

- 메시지 처리 로직이 멱등하면 중복 메시지는 전혀 해롭지 않음
- 이렇게 멱등한 애플리케이션 로직은 별로 없음
- 중복 메시지와 순서가 안 맞는 메시지는 오류를 일으키기 떄문에 중복 메시지를 솎아내는 메시지 핸들러 필요

### 메시지 추적과 중복 메시지 솎아 내기

- 컨슈머가 메시지 ID를 사용하여 메시지 처리 여부를 추적하면 간단히 해결
(예 - 컨슈머가 소비하는 메시지 ID를 무조건 DB에 저장)
    
    ![Untitled](3%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%20%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%90%E1%85%A9%E1%86%BC%E1%84%89%E1%85%B5%E1%86%AB%2094428438f3854bc9a0b4025c9c244aa8/Untitled%208.png)
    
    - 새로운 테이블에 무조건 저장
    - 혹은 일발 애플리케이션 테이블에 메시지 ID를 기록하는 방법
    한 DB 트랜잭션으로 두 테이블을 업데이트하는 일이 불가능한, 트랜잭션 모델이 제한적인 NoSQL DB를 쓸 때 유용

## 3.3.7 트랜잭셔널 메시징

- 서비스는 보통 DB를 업데이트하는 트랜잭션의 일부로 메시지를 발행
- 두 작업이 서비스에서 원자적으로 수행되지 않으면 시스템이 실패할 경우 아주 불안정한 상태로 됨
- 예전에는 DB와 메시지 브로커에 분산 트랜잭션을 적용했지만, 요즘은 더 이상 어울리지 않음
- 더구나 현대 메시지 브로커는 대부분 분산 트랜잭션을 지원하지 않음

### DB 테이블을 메시지 큐로 활용

- RDBMS 기반의 애플리케이션이라면 DB 테이블을 임시 메시지 큐로 사용하는 트랜잭셔널 아웃박스 패턴이 가장 알기 쉬운 방법

![Untitled](3%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%20%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%90%E1%85%A9%E1%86%BC%E1%84%89%E1%85%B5%E1%86%AB%2094428438f3854bc9a0b4025c9c244aa8/Untitled%209.png)

- 로컬 ACID 트랜잭션이기 때문에 원자성은 자동 보장
- OUTBOX 테이블은 임시 메시지 큐 역할
- 메시지 릴레이는 OUTBOX 테이블을 읽어 메시지 브로커에 메시지를 발행하는 컴포넌트
- NoSQL DB도 방법은 비슷

### 이벤트 발행: 폴링 발행기 패턴

- 메시지를 발행하는 가장 간단한 방법은 메시지 릴레이로 폴링해서 미발행 메시지를 조회
- 메시지 브로커에 발행된 메시지는 나중에 OUTBOX 테이블에서 메시지를 삭제
- 규모가 작을 때 쓸 수 있는 단순한 방법
- DB를 자주 폴링하면 비용이 유발, NoSQL DB는 쿼리 능력에 따라 사용 가능 여부 결정

### 이벤트 발행: 트랜잭션 로그 테일링 패턴

- 메시지 릴레이로 DB 트랜잭션 로그(커밋 로그)를 테일링
- 트랜잭션 로그 마이너로 로그를 읽어 변경분을 하나씩 메시지로 메시지 브로커에 발행
- 응용 사례
    - 디비지움(Debezium) : DB 변경분을 아파치 카프카 메시지 브로커에 발행하는 오픈 소스 프로젝트
    - 링크드인 데이터버스 : 오라클 트랜잭션 로그를 마이닝하여 변경분을 이벤트로 발행하는 오픈 소스 프로젝트
    - DynamoDB 스트림즈 : 최근 25시간 동안 테이블 아이템에 적용된 변경분을 시간 순으로 정렬한 테이터를 가짐, 이를 읽어 이벤트로 발행 가능
    - 이벤추에이트 트램 : 필자가 개발한 오픈 소스 트랜잭션 라이브러리

## 3.3.8 메시징 라이브러리/프레임워크

- 서비스가 메시지를 주고 받기 위해서는 라이브러리가 필요
- 메시지 브로커에도 클라이언트 라이브러리가 있지만 직접 사용하면 다음과 같은 문제 발생
    - 메시지 브로커 API에 메시지를 발행하는 비즈니스 로직이 클라이언트 라이브러리와 결합
    - 메시지 브로커의 클라이언트 라이브러리는 대부분 저수준, 주고 받는 코드가 꽤 긴편
    판박이 코드가 많아 짐
    - 클라이언트 라이브러리는 기본적인 메시지 소통 수단일 뿐, 고수준의 상호 작용 스타일은 지원하지 않음
- 따라서 저수준은 감추고 고수준의 상호 작용 스타일을 직접 지원하는 라이브러리 혹은 프레임워크 필요
- 이벤추에이트 트램에는 중요한 메커니즘 존재
    - 트랜잭셔널 메시징 : 메시지를 DB 트랜잭션의 일부로 발행
    - 중복 메시지 감지

### 기초 메시징

- MessageProducer, MessageConsumer 두 인터페이스로 구성
- MessageProducer 인터페이스를 통해 메시지를 메시지 채널에 발행
    
    ```java
    MessageProducer messageProducer = ...;
    String channel = ...;
    String payload = ...;
    messageProducer.send(destination, MessageBuilder.withPayload(payload).build())
    ```
    
- MessageConsumer 인터페이스를 통해 메시지를 구독
    
    ```java
    MessageConsumer messageConsumer;
    messageConsumer.subscribe(
    	subscriberId, 
    	Collections.singleton(destination),
    	message -> {...}
    )
    ```
    

### 도메인 이벤트 발행

- 도메인 이벤트는 비즈니스 객체를 생성, 수정, 삭제 시 애그리거트가 발생시킨 이벤트
- DomainEventPublisher 인터페이스를 통해 도메인 이벤트 발행
    
    ```java
    DomainEventPublisher domainEventPublisher;
    String accountId = ...;
    DomainEvent domainEvent = new AccountDebited(...);
    domainEventPublisher.publish(
    	"Account", 
    	accountId, 
    	Collections.sigletonList(domainEvent)
    )
    ```
    
- 서비스는 DomainEventDispatcher 클래스로 도메인 이벤트를 소비
    
    ```java
    DomainEventHandler domainEventHandler = DomainEventHandlerBuilder
    	.forAggregateType("Order")
    	.onEvent(AccountDebited.class, domainEvent -> {...})
    	.build();
    
    new DomainEventDispatcher(
    	"eventDispatcherId",
    	domainEventHandlers,
    	messageConsumer
    );
    ```
    

### 커맨드/응답 메시징

- 클라이언트는 CommandProducer 인터페이스를 이용하여 커맨드 메시지를 서비스에 보냄
    
    ```java
    CommandProducer commandProducer = ...;
    
    Map<String, String> extraMessageHeaders = Collections.emptyMap();
    
    String commandId = commandProducer.sned(
    	"CustoemrCommandChannel",
    	new DoSomethingCommand(),
    	"ReplyToChannel",
    	extraMessageHeaders
    );
    ```
    
- 서비스는 CommandDispatcher 클래스로 커맨드 메시지를 소비
    
    ```java
    CommandHandlers commandHandlers = CommandHandlersBuilder
    	.fromChannel(commandChannel)
    	.onMessage(
    		DoSomethingCommand.class, 
    		(command) -> {
    			...;
    			return withSuccess();
    		}
    	).build();
    
    CommandDispatcher dispatcher = new CommandDispatcher(
    	"subscribeId",
    	commandHandlers,
    	messageConsumer,
    	messageProducer
    );
    ```
    

# 3.4 비동기 메시징으로 가용성 개선

## 3.4.1 동기 통신으로 인한 가용성 저하

- REST는 대중적이라 끌리지만, 동기 프로토콜로 통신하면 그만큼 가용성은 저하
    
    ![Untitled](3%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%20%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%90%E1%85%A9%E1%86%BC%E1%84%89%E1%85%B5%E1%86%AB%2094428438f3854bc9a0b4025c9c244aa8/Untitled%2010.png)
    
- 세 서비스 모두 HTTP를 사용하기 때문에 주문 생성 요청이 처리 되려면 세 서비스가 모두 가용중이여야 함
- 비동기 메시징을 통해 요청/응답하는 방식도 응답을 기다린다면 가용성은 떨어짐

## 3.4.2 동기 상호 작용 제거

### 비동기 상호 작용 스타일

- 모든 트랜잭션은 비동기 상호 작용 스타일로 처리하는 것이 가장 좋음
    
    ![Untitled](3%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%20%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%90%E1%85%A9%E1%86%BC%E1%84%89%E1%85%B5%E1%86%AB%2094428438f3854bc9a0b4025c9c244aa8/Untitled%2011.png)
    
- 클라이언트/서비스는 메시징 채널을 통해 메시지를 전송하여 비동기 통신을 함
- 이러한 상호 작용 과정에서는 어느 쪽도 응답을 대기하며 블로킹되지 않음
- 메시지 또한 버퍼링을 하여 매우 탄력적
- 하지만 REST와 같은 동기 프로토콜을 사용하는 즉시 응답하는 외부 API도 존재할 것

### 데이터 복제

- 서비스 요청 처리에 필요한 데이터의 레플리카를 유지하는 방법
- 데이터 레플리카는 데이터를 소유한 서비스가 발행한 이벤트를 구독해서 최신 데이터를 유지
- 항상 요청하여 응답값을 받는 것이 아닌 데이터가 변경될 때마다 이벤트를 발행, 이로써 레플리카를 업데이트
- 하지만 대용량 데이터의 레플리카는 비효율적이고 다른 서비스가 소유한 데이터를 업데이트하는 문제도 있음
- 한 가지 해결 방법은 자신의 클라이언트에 응답하기 전까지 다른 서비스와 상호 작용을 지연

![Untitled](3%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%20%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%90%E1%85%A9%E1%86%BC%E1%84%89%E1%85%B5%E1%86%AB%2094428438f3854bc9a0b4025c9c244aa8/Untitled%2012.png)

### 응답 반환 후 마무리

- 요청 처리 도중 동기 통신을 제거하기 위해선 다음과 같음
    - 로컬에서 가용한 데이터만 갖고 요청을 검증
    - 메시지를 OUTBOX 테이블에 삽입하는 식으로 DB를 업데이트
    - 클라이언트에 응답 반환
- 예시로 주문 서비스라면, 주문을 PENDING 상태로 생성, 다른 서비스와 메시지를 고환하여 주문을 비동기 검증
    
    ![Untitled](3%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%20%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%90%E1%85%A9%E1%86%BC%E1%84%89%E1%85%B5%E1%86%AB%2094428438f3854bc9a0b4025c9c244aa8/Untitled%2013.png)
    
- 주문 서비스는 어떤 순서로든 메시지를 받을 수 있음
- 자신이 최초로 수신한 메시지에 따라 주문 상태를 변경
- 이처럼 요청을 완전히 처리하기 전에 클라이언트에 응답하는 서비스는 클라이언트 코드가 복잡
- 최초 응답 반환 시에 최소한의 정보만 보장
- 따라서 클라이언트 입장에서는 주문 생성 성공 여부를 알아내려면 주기적으로 폴링 혹은 주문 서비스가 알림 메시지를 주는 것