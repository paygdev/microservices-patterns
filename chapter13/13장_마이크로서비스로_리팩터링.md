# 13장 마이크로서비스로 리팩터링  
 모놀리식 애플리케이션을 마이크로서비스 아키텍처로 전환하는 시점, 
 모놀리식을 마이크로서비스로 단계적으로 리팩터링해야 하는 이유, 
 새 기능을 서비스로 구현, 
 모놀리스에서 서비스 추출, 
 서비스와 모놀리스 연계등 주제를 훑어 본다.  
 
## 13.1 마이크로서비스 리팩터링 개요 
스트랭글러 애플리케이션(strangler application)을 개발해서 단계적으로 모놀리식을 마이크로서비스로 전환 필요

### 13.1.1 모놀리스를 왜 리팩터링하는가?
- 마이크로서비스 아키텍처 장점:  유지보수성,테스트성,배포성,빠른 개발 속도, 확장성, 오류 격리성이나 
- 모놀리스를 마이크로서비스로 전환 시에 개발 리소스가 분산되는 어려움이 있음  
- 모놀로식 지옥에서 격는 문제
  - 느린전달 :애플리케이션을 이해,관리, 테스트가 어려워 생산성이 떨어짐
    - 느린전달의 이유는 개발 프로세스가 낙후됨이고, 
  - 버그 투성이 소프트웨어 릴리스 : 테스트가 결여되어 버그가 많이 발생
    - 버그는 수동테스트에 의존하므로 자동테스트를 도입해 개선가능,
  - 나쁜 확장성 : 모듈간의 연관성이 깊어 확장하기 어려움
    - 확장 문제는  간단한 방안 부터 시행해보고 그래도 문제가 해결되지 않을 경우 마이크로서비스로 전환을 고려


### 13.1.2 모놀리스 옥죄기  
   
   <center> <img src="/fig13-1.png" width="850" height="650"></center> 
  
- 많은 사람들이 깨달은 가장 중요한 교훈: 완전히 뜯어고치기(big bang rewrite)를 삼가하라
- 스트랭글러 애플리케이션 패턴: 레거시 애플리케이션에 새 (스트랭글러) 애플리케이션을 에둘러 단계적으로 개발하는 애플리케이션 현대화 패턴


## 13.2 모놀리스 → 마이크로서비스 리팩터링 전략
- 모놀리스를 마이크로서비스로 교체하는 3단계 전략 
  1. 새 기능을 서비스로 구현 
  2. 표현계층과 백엔드를 분리 
  3. 기능을 여러 서비스로 추출해서 모놀리스를 분해 

#
### 13.2.1 새 기능을 서비스로 구현한다
- 모놀리식을 마이크로로 전환할때, 새 기능을 마이크로서비스로 구현 하는것 부터 진행한다. 
- 모놀리스에 새 기능을 추가하게 되면 비대해지고, 관리하기 어려움

#### 새 서비스를 모놀리스에 연계 
- 새 서비스와 모놀리스를 통합하는 두 개의 요소  
 - API 게이트웨이: 새 기능 요청은 새 서비스로, 기존 기능은 모놀리스로 각각 라우팅
 - 통합 글루 코드(integration glue code): 새 서비스가 모놀리스 데이터에 접근하고 모놀리스에 구현된 기능을 호출할 수 있게 새 서비스를 모놀리스에 통합   
   - 통합 글루 코드는 스탠드얼론 컴포넌트가 아닌, 모놀리스에 있는 어뎁터 및 하나 이상의 IPC를 사용하는 서비스이다 


#### 새 기능을 서비스로 구현하는 시점 (제목/내용 불일치)
   <center> <img src="/fig13-2.png" width="850" height="750"></center> 
   
- 새 서비스로 구현하기 어려운 경우
  1. 의미있는 서비스라고 하기에는 기능 자체가 너무 작은 경우 : 기존 클래스에 필드/메스드 몇개만 추가하면 되는 경우
  2. 새 기능이 기존 모놀리스코드에 너무 단단히 매여있는 경우: 과도한 IPC가 발생, 새로운 성능문제 야기 
  3. 데이터 일관성을 보장 하기 힘든 경우: 새 기능을 서비스로 구현할 수 없는 경우 
- 일단 모놀리스에 새 기능을 구현하고, 나중에 다른 관련 기능과 함께 해당기능 자체를 서비스로 추출할 수 있음    
   
### 13.2.2 표현 계층과 백엔드를 분리한다
- 표현 계층을 비즈니스 로직과 데이터 접근 계층에서 분리하면서 덩치를 줄인다.
- 엔터프라이즈 애플리케이션의 세가지 계층은 다음과 같다.
 1. 표현계층 : HTTP요청을 처리해 웹 UI에 전달할 HTML을 생성하는 모듈
 2. 비즈니스 로직 : 복잡한 비즈니스 규칙이 구현된 모듈
 3. 데이터 접근로직 : DB, 메시지 브로커등 인프라 서비스에 접근하는 모듈
 
    <center> <img src="/fig13-3.png" width="850" height="750"></center> 
- 비즈니스 로직에는 하나 이상의 퍼사드로 구성된 API 가 존재하는데 이 API가 모놀리스를 작은 단위로 쪼갤 수 있는 부분이다. 
- 즉, 표현계층이 포함된 애플리케이션 A, 비즈니스/ 데이터 접근 로직이 포함된 애플리케이션B 이렇게 두 개로 나눌 수 있다. 

- 이렇게 나누면, 두 시스템이 독립적으로 개발, 배포, 확장할 수 있다. 또 나중에 개발 할 마이크로서비스가 호출 할 수 있는 원격 API 가 구분된다.


### 13.2.3 기능을 여러 서비스로 추출한다
- 모놀리스를 서비스로 추출해야 할 4가지 기능
 1. API 끝점이 구현된 인바운드 어댑터
 2. 도메인로직
 3. DB접근 로직 등이 구현된 아웃바운드 어댑터
 4. 모놀리스의 DB 스키마
    <center> <img src="/fig13-4.png" width="850" height="650"></center>   
- 모놀리스에서 코드를 추출해 스탠드론 서비스로 이전한다.  [그림 13-4]
- API 게이트웨이는 요청에 따라, 새 기능은 마이크로 서비스로, 나머지는 모놀리스로 각각 라우팅한다 
- 모놀리스에서 서비스를 추출해가는 과정은 시간이 많이 걸린다. 따라서 신중하게 결정 해야 한다
- 새 서비스로 추출시 가장 중요하고 계속 발전하는 서비스를 먼저 추출하는 것이 좋다.

   
#### 도메인 모델 분리
 - 모놀리스 도메인 모델에서 서비스 도메인 모델 추출
    <center> <img src="/fig13-5.png" width="850" height="350"></center>   
 - 서비스 경계에 있는 객체 레퍼런스를 분리하는것은 어려움 : 모놀리스에 잔류한 클래스가 이전한 클래스를 찾거나, 이전한 클래스가 모놀리스를 참조할 수 있음
   - DDD 의 애그리거트 관점으로 생각해야 함. 애그리거트는 객체 레퍼런스 대신, 기본키로 서로를 참조하기때문
    <center> <img src="/fig13-6.png" width="850" height="350"></center>   


#### DB 리팩터링
- 모놀리스에 있던 DB테이블도 서비스DB로 이전해야 함 
- 엔티티를 나누려면 DB테이블도 분리 해야 한다.  
- 가령 ORDER 테이블이라면, Delivery 엔티티를 추출해서 DELIVERY 테이블을 새로 만들고, 그런 다음 DELIVERY 테이블을 Delivery 서비스로 이전한다.
 


#### 변경 범위를 줄이기 위해 데이터를 복제
- DB 리팩터링에서 가장 큰 장애물은, DB를 참조하고 있는 클라이언트가 새 스키마를 사용하도록 전체 변경하는 일이다. 
- 전이 기간동안 원본 스키마를 유지하고 원본 스키마와 신규 스키마를 동기화 하는 트리거 등을 사용 한다. 

   <center> <img src="/fig13-7.png" width="850" height="750"></center>   

 

#### 어떤 서비스를 언제 추출하나
 - 시간별로 구획된 아키텍처(time-boxed architecture) 정의부터 시작하는 것이 좋다. 
 - 1~2주 정도 짧은 시간을 들여 어떤 아키텍처가 이상적인지 생각해보고, 알맞는 서비스를 정의한다.  
 - 그런뒤, 본격적으로 모놀리스를 나눈다.

 - 다음은 서비스 추출 순서를 정하는 전략 두가지이다.

 1. 모놀리스의 개발을 동결하고, 요건이 있을 때마다 서비스를 추출하는 것이다. 모놀리스의 버그를 잡지 말고, 필요한 서비스를 추출해서 고쳐 개발하는것
 2. 서비스 추출시 기대되는 혜택을 모듈별로 순위를 매기는 것이다.
   - 개발가속화 : 개발 일정상, 개발 분량이 많을 것으로 예상 되는 파트를 서비스로 전환한다.
   - 성능, 확장성, 신뢰성 문제해결 : 성능, 확장성에 문제가 있거나 의심스러운 부분은 전환 할 만한 가치가 있다.
   - 다른 서비스로 추출할 수 있게 만듦 : 먼저 추출하면 디펜던시상 다른 서비스분리가 단순해지는 경우.


  
##
## 13.3 서비스와 모놀리스 간 협동 설계
- 마이크로서비스 전환과정에서 모놀리스와 서비스는 협동하며 수행된다. 
- 서비스가 모놀리스에 접근하거나, 모놀리스가 서비스에 접근해 필요한 데이터를 가지고 와야 한다. 
- 여기서 중요한건 두 서비스간에 데이터 일관성 유지이다. 
- 경우에 따라 SAGA로 데이터 일관성을 맞추어야 한다.  
- 서비스와 모놀리스간의 상호작용은 통합 글루 코드가 관장한다. 
   <center> <img src="/fig13-8.png" width="850" height="450"></center> 

### 13.3.1 통합 글루 설계
- 통합 글루코드는 모놀리스와 서비스 양쪽에 구성한다.
 1. 서비스가 모놀리스를 REST호출한 경우: 서비스에는 REST 클라이언트, 모놀리스에는 웹 컨트롤러가 위치한 통합 글루가 구성
 2. 서비스가 발행한 도메인 이벤트를 모놀리스가 구독하는 구조: 서비스에 이벤트 발행 어뎁터, 모놀리스에 이벤트 핸들러를 거느린 통합글루가 구성 

#### 통합 글루 API 설계
- 통합 글루를 설계 시 도메인 로직에 어떤 API를 제공할지 결정해야 한다. 
- 서비스의 비즈니스 로직은 통합 글루가 어떤 IPC 로 데이터를 가지고 오는지 알 필요가 없으므로, IPC를 인터페이스로 캡슐화 하여 제공한다. 
- 모놀리스의 비즈니스 로직은 통합 글루가 어떻게 구현했든 알 필요 없이 단순히 API를 호출하면 된다  


#### 상호 작용 스타일과 IPC 선택
- 통합 글루에서 중요한 건 모놀리스와 서비스가 협동할 수 있게 해주는 상호작용 스타일과 IPC를 선택하는 일이다.
<center> <img src="/fig13-9.png" width="850" height="450"></center> 

- 조회하는 경우>> 
 1. 조회API를 이용하는 방식 : 단순해 편리하지만 요청 개수가 많아지면 효율이 나빠진다.
 2. 데이터 레플리카(CQRS 뷰)를 유지하는 방법 
   - 데이터 컨슈머는 데이터 프로바이더가 발행한 도메인 이벤트를 구독해서 이 레플리카를 최신으로 유지한다. 
   - 데이터 프로바이더를 반복해서 조회하는 쿼리 오버해드를 줄일 수 있다.   
   
<center> <img src="/fig13-10.png" width="850" height="450"></center>  

- 수정하는 경우 >> 
- 서비스와 모놀리스 모두 데이터 일관성을 유지해야 함
- 서비스와 모놀리스가 이벤추에이트 트램 같은 프레임워크에 구현된 트랜잭셔널 메시징으로 통신, SAGA 나 이벤트를 사용해 양쪽 데이터베이스의 일관성을 유지해야 

#### 부폐-방지 계층(ACL: Anti-Corruption Layer)구현 
- 마이크로서비스를 완전히 새로 개발 할 경우, 전혀 다른 클래스명, 필드명, 필드값등을 가지게 될 것이다. 
- 모놀리스와 서비스가 서로 소통하려면 DDD 에서 말하는 ACL(Anti-Corruption Layer, 부패-방지 계층)을 구현 해야한다.
- ACL이란 상이한 두 도메인 모델이 서로 상대편을 더럽히지 않도록 변환해 주는 소프트웨어 계층이다. 
- ACL의 목표는 레거시 모놀리스의 도메인 모델이 서비스 도메인 모델을 더럽히지 못하게 만드는 것이다. 

<center> <img src="/fig13-11.png" width="850" height="450"></center>  

<center> <img src="/fig13-12.png" width="850" height="450"></center> 



#### 모놀리스가 도메인 이벤트를 발행/구독하는 방법 
- 모놀리스가 이벤트를 발행하는 방법은 두 가지이다.
 1. 서비스가 사용하는것과 동일한 이벤트 발행 장치를 적용하는 방법
   - 엔티티를 변경하는 코드를 모두 찾아내어 이벤트 발행 API 를 삽입 하는 방식이다. 
   - 하지만 이렇게 모든 변경코드를 찾아내기는 쉽지 않고, 저장프로시저형태로 구현된 로직은 이벤트 발행 자체가 불가능하다.
 2. DB수준에서 이벤트를 발행 하는 방법
   - 트랜잭션 로그 테일링이나 폴링을 사용한다. 
   - 이 방법은 간편하지만, DB수준에서만 이벤트를 발행할 뿐이고, 고수준의 비즈니스 이벤트는 발행 하기 어렵다.  
   - 

- 서비스가 발행한 도메인 이벤트는 모놀리스에서 쉽게 구독가능 : 이벤추에이트 트램 같은 프레임워크로 이벤트 핸들러 작성 
- 메시지 브로커 클라이언트를 지원하지 않는 언어로 모놀리스가 개발되었다면, 이벤트를 구독하는 helper 애플리케이션을 작성하여 모놀리스 DB직접 업데이트할 필요



### 13.3.2 서비스와 모놀리스에 걸쳐 데이터 일관성 유지
- 서비스와 모놀리스가 데이터의 일관성을 유지하는 것은 상당히 어렵다. 
- 두 서비스가 모두 수정작업이 이루어지기때문이다. 
- 모놀리스에 SAGA로직을 추가하는 것은 어려운 일이다. 
- 모놀리스에 있는 트랜젝션이 피봇 트랜잭션이거나, 재시도 가능 트랜잭션이면 어렵지 않다. 또, 보상 트랜잭션을 수행 할 필요가 없도록 서비스 추출 순서 조정. ?? 

보상 트랜잭션을 지원하도록 모놀리스를 고치기는 어렵다.
사가 적용시 모놀리스는 보상 트랜잭션을 지원할 필요가 없다.
서비스 추출 순서를 조정하면 보상 트렌젝션을 모놀리스에 구현하지 않아도 된다. 

 
 
### 13.3.3 인증/인가 처리
-모놀리스에 구현된 보안 메커니즘은 마이크로서비스에 맞게 조정 되어야 한다. 

<center> <img src="/fig13-13.png" width="850" height="650"></center> 




## 13.4 새 기능을 서비스로 구현: 배달 실패한 주문 처리
구현해야 할 새 기능 
1. 주문이 제시간에 배달되지 못하면 이 사실을 고객에게 알립니다. 
2. 음식점 영업 종료전에 주문 픽업을 할 수 없어 배달 자체가 불가능한 경우, 이 사실을 고객에게 알립니다. 
3. 주문을 제 시간에 배달할 수 없을 경우, 고객 서비스 센터에 연락해서 미리 고객에게 보상책을 제시하는 식으로 상황을 해결하도록 한다
4. 배달 통계를 추적한다 
=> 모놀리스로 구현 시, 코드 개발/ 테스트 어렵고 모놀리스가 커짐. 

### 13.4.1 배달 지연 서비스 설계

<center> <img src="/fig13-14.png" width="850" height="650"></center>   

### 13.4.2 배달 지연 서비스를 위한 통합 글루 설계
- Order, Restaurant엔티티는 모놀리스 데이터를 복제하여 가져옴 
- 모놀리스는 Order, Restaurant 도메인 이벤트를 발생하고 배달 지연 서비스는 이 이벤트를 수신하여 각 엔티티별 레플리카 업데이트 
- 배달 지연 서비스는 이 이벤트를 수신하여 각 엔티티별 레플리카 업데이트 
- 배달 지연 서비스는 주문을 재시간에 배달할 수 없을 경우, 고객 연락처를 조회하는 모놀리스의 REST끝점을 호출해서 해당고객에게 지연사실을 알림  
<center> <img src="/fig13-15.png" width="850" height="550"></center>  

#### CustomerContactInfoRepository로 고객 연락처 조회  
- 배달 지연 서비스가 고객 연락처를 조회할 일이 비교적 적고 데이터 크기도 아주 작기 때문에 지연이나 성능 이슈는 거의 발생할 일이 없음 
- 이 인터페이스는 모놀리스의 GetCustomerContactInfo를 호출하여 고객 정보를 조회하는 CustomerContactInfoProxy가 구현함. 
  
#### 주문/음식점 도메인 이벤트의 발핼과 소비 
- 모놀리스가 발행한 이벤트를 구독해서Order, Restaurant레플리카를 유지하는 방법을 사용 
- 레플리카는 모놀리스 데이터를 전부 다 복사하는 것이 아니라 Orer, Restaurant 엔티티 중 일부 속성에 해당하는 하위 집합만 저장한다.  

## 13.5 모놀리스 분해: 배달 관리 추출
### 13.5.1 현행 배달 관리 기능
  - 배달관리는 주문관리 일로 삽입되어 있다.
<center> <img src="/fig13-16.png" width="850" height="900"></center>  

### 13.5.2 배달 서비스 개요
- 배달 서비스를 추출한 이후, 고수준에서 바라본 FTGO 애플리케이션 아키텍처 [그림 13-17]
- 이 아키텍처를 구성하는 모놀리스와 배달서비스는 양쪽에 다 있는 통합글루 API를 통해 서로 협동한다 
- 배달 서비스는 자체 도메인 모델과 DB를 갖고 있다 
<center> <img src="/fig13-17.png" width="850" height="650"></center>  

### 13.5.3 배달 서비스의 도메인 모델 설계
#### 배달 관리를 구성할 엔터티/필드 식별
- 배달관리 일부에 해당하는 엔터티와 필드 [그림13-18]
<center> <img src="/fig13-18.png" width="650" height="550"></center>  

#### 배달 서비스로 이전할 데이터 결정 
- 서비스는 어떻게 모놀리스에 잔류한 데이터에 접근할 것인가? 
- 모놀리스는 어떻게 서비스로 이전된 데이터에 접근할 것인가? 
- 서비스와 모놀리스 간 데이터 일관성을 유지
- 예) 배달 서비스의 주 임무는 배달원 계획을 관리하고 Order테이블의 scheduledPickupTime, scheduledDeliveryTime을 업데이트 하는 것
  - 배달서비스 : scheduledPickupTime, scheduledDeliveryTime
  - 모놀리스: location, availability필드 (가급적 변경 최소화) 

#### 배달 서비스 도메인 로직 설계 
- DeliveryServiceImpl : 배달 관리 비즈니스 로직의 진입점, DeliveryService, CourierService 인터페이스를 구현한 클래스  
- 배달관리 비즈니스 로직은 대부분 모놀리스에서 복사해 온 것, 예)모놀리스의 Order엔티티를 이름만 Delivery로 바꿔 배달서비스로 복사  
<center> <img src="/fig13-19.png" width="750" height="650"></center>  

### 13.5.4 배달 서비스의 통합 글루 설계
#### 배달 서비스 API설계
- 배달 서비스는 모놀리스가 배달 스케줄을 잡거나 변경/취소할 수 있는 API를 제공해야 함 
<center> <img src="/fig13-20.png" width="850" height="450"></center> 

  - 모놀리스에서 발행된 Order 도메인 이벤트를 배달 서비스가 구독하는 방법
    - 모놀리스가 명시적으로 배달 서비르를 호출할 필요가 없다는 장점은 있지만, 도메인 이벤트에 의존하게 되면 각 Order 이벤트가 Delivery에 어떤 영향을 미치는지 배달 서비스가 알고 있어야 하는 단점이 있습니다.
  - 모놀리스가 배달 서비스에 명시적으로 Delivery를 생성, 변경, 취소하도록 지시할 수 있도록 알림 기반의 API를 배달 서비스에 구현하는 것이 좋다.
    - 주문이 어떻게 돌아가는지 배달 서비스가 몰라도 된다는 것이 이 방법의 가장 중요한 장점입니다. 배달 서비스는 오로지 배달 관리에만 집중할 뿐, 주문에 대해서는 아무것도 모릅니다.


#### 배달 서비스가 모놀리스 데이터에 접근하는 방법 
#### 모놀리스가 배달 서비스 데이터에 접근하는 방법 


### 13.5.5 배달 서비스와 상호 작용할 수 있게 모놀리스를 변경
#### DeliveryService 인터페이스 정의 
<center> <img src="/fig13-21.png" width="650" height="450"></center> 

#### DeliveryService 인터페이스를 호출하도록 모놀리스 리팩터링 


#### DeliveryService 인터페이스 구현 
<center> <img src="/fig13-23.png" width="850" height="600"></center> 



