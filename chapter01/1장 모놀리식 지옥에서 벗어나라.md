# 1장. 모놀리식 지옥에서 벗어나라

## 1.1. 서서히 모놀리식 지옥에 빠져들다
	FTGO(Food to Go) 애플리케이션은 모놀리스로 개발되었는데, 점차 소프트웨어 전달 페이스가 느려졌고,  모놀리식 지옥에 빠지는 증상을 보임

### 1.1.1 FTGO 애플리케이션 아키텍처 
	FTGO 애플리케이션 아키텍처는 육각형 아키텍처(Hexagonal Architecture)이다.
	
<center> <img src="/fig1-1.PNG" width="800" height="500"> </center>
[그림1-1] FTGO 애플리케이션 


※ 육각형 아키텍처 (Hexagonal Architecture) 
	
<center> <img src="/fig1.PNG" width="600" height="400"> </center>

	- 육각형 아키텍처는 코어가 비즈니스 로직으로 구성되어 있으며, UI구현 및 외부시스템과 통신하는 하나이상의 어탭터로 구성되어 있다. 
	- 비즈니스 로직은 하나 이상의 포트를 지닌다. 
 	- 인바운드 어댑터는 외부시스템의 요청을 처리하고 인바운드 포트를 호출한다. 
	- 아웃바운드 어댑터는 아웃바운드 포트를 통해 외부 시스템을 호출한다. 
	- 도메인 영역 → 인프라 영역으로는 접근 가능 하지만, 반대로는 불가능 하게 구성 해야함  
	- 무조건 포트, 어댑터를 통해서만 도메인 영역에서 인프라 영역으로 접근하게 해야함.   
	- 이렇게 아키텍처를 구성함으로써 느슨한 결합을 유지 할 수 있음.
 
### 1.1.2 모놀리식 아키텍처 장점 
	- 개발이 간단하다
  	- 애플리케이션을 쉽게 변경할 수 있다
  	- 테스트가 쉽다 
  	- 배포가 쉽다 
  	- 확장하기 쉽다
  
### 1.1.3 모놀리식 지옥의 실상 
 	- 너무 복잡해서 개발자가 주눅들다 
 	- 개발이 더디다 
 	- 커밋부터 배포에 이르는 길고 험난한 여정 
	- 확장하기 어렵다 
 	- 모놀리스는 확실하게 전달하기 어렵다 
 	- 갈수록 한물간 기술 스택에 발목이 붙잡히다

<br/><br/><br/>

## 1.2 이 책의 대상 독자 
	모놀리식에서 탈출/우회하고 싶은 독자. 
 

<br/><br/><br/>
 
## 1.3 이 책의 학습 내용 
	- 마이크로서비스의 주요 특성과 장단점, 사용 시점
	- 분산 데이터 관리 패턴
	- 효과적인 마이크로서비스 테스트 전략
	- 마이크로서비스 배포 옵션
	- 모놀리식 아키텍처를 마이크로서비스 아키텍처로 리팩터링하는 전략

<br/><br/><br/>

## 1.4 마이크로서비스 아키텍처가 답이다
	 모놀로지식 지옥에서 벗어나려면 반드시 마이크로서비스라는 새 아키텍처로 갈아타야한다. 

### 1.4.1 확장큐브와 마이크로서비스
	확장 큐브 모델에 따르면 애플리케이션을 X축, Y축, Z축 세 방향으로 확장시킬 수 있습니다.

<center> <img src="/fig1-3.jpg" width="800" height="500"> </center>
[그림 1-3] 확장 큐브   

<br/>
<br/>

#### 1. X축 확장: 다중 인스턴스에 고루 요청 분산
	- X축 확장은 일반적인 모놀리식 애플리케이션의 확장 수단
	- 부하 분산기 뒷면에 애플리케이션 인스턴스를 N개 띄워 놓고 부하 분산기는 들어온 요청을 이들 인스턴스에 고루 분배(그림 1-4).
	- 애플리케이션 능력과 가용성을 개선할 수 있는 훌륭한 방법

 <center> <img src="/fig1-4.jpg" width="800" height="500"> </center>
  [그림1-4] X축 확장
 
<br/>
<br/>

#### 2. Z축 확장: 요청 속성별 라우팅
	- 모놀리식 애플리케이션의 다중 인스턴스를 실행하는 것은 X축 확장과 같지만, 
	- 인스턴스별로 주어진 데이터 하위 집합만 처리하도록 설정하는 방법(그림 1-5).
	- 인스턴스 앞면에 위치한 라우터는 요청의 속성에 알맞은 인스턴스로 요청을 라우팅합니다(예: userId에 따라 요청을 분산).
	- 그림 1-5에서 각 애플리케이션 인스턴스는 자신에게 배정된 사용자 하위 집합만 처리
	- 라우터는 요청 헤더 Authorization에 포함된 userId를 보고 N개의 동일한 애플리케이션 인스턴스 중 하나를 선택
	- Z축 확장은 애플리케이션을 확장해서 증가하는 트랜잭션 및 데이터 볼륨을 처리하기 좋은 수단

 <center> <img src="/fig1-5.jpg" width="800" height="500"> </center>
 
 [그림1-5] z축 확장
 


#### 3. Y축 확장: 기능에 따라 애플리케이션을 서비스로 분해
	- X축/Z축 확장을 하면 애플리케이션 능력과 가용성은 개선되지만, 애플리케이션이 점점 더 복잡해지는 문제는 해결되지 않음. 
	- 따라서 Y축 확장, 즉 기능 분해가 필요합니다(그림 1-6). 모놀리식 애플리케이션을 여러 서비스로 쪼개는 것
	- 서비스는 주문 관리, 고객 관리 등 지엽적 기능이 구현된 미니 애플리케이션입니다. 
	- 서비스에 따라 X축/Z축 확장도 가능하죠. 예를 들어 주문 서비스는 여러 서비스 인스턴스를 부하 분산하는 형태로 구성.
	- 마이크로서비스 아키텍처는 고수준에서 바라보면 하나의 애플리케이션을 여러 서비스로 기능 분해하는 아키텍처 스타일. 
	- 여기서 중요한 것은 크기가 아니라, 각 서비스가 집중된(focused)/응집된(cohesive) 책임을 맡고 있다는 사실임. 

<center> <img src="/fig1-6.jpg" width="800" height="500"> </center>
 [그림1-6] y축 확장
 



### 1.4.2 마이크로서비스는 모듈성을 갖고 있다
 
 	- 마이크로서비스 아키텍처는 서비스를 모듈성(modularity)의 단위로 사용함.
 	- 각 서비스는 다른 서비스가 함부로 규칙을 어기고 침투하지 못하게 API라는 경계선을 갖고 있음
	- 다른 서비스 API를 우회하여 그 내부 클래스에 마음대로 들어올 수 없음. 
	- 따라서 시간이 지나도 애플리케이션 모듈성을 유지하기가 훨씬 수월 
 	- 서비스를 빌딩 블록처럼 사용하여 독립적으로 배포/확장할 수 있음.

 ### 1.4.3 서비스마다 DB가 따로 있다
 	- 마이크로서비스는 서로 느슨하게 결합되어 있고, 오직 API를 통해서만 통신하고, 각각 자체 DB를 갖고 있음. 
 	   ex) 가령 주문 서비스는ORDERS 테이블이 있는 DB를, 고객 서비스는 CUSTOMERS 테이블이 있는 DB를 각자 소유. 
 	- 개발 단계에서 다른 서비스 개발자와 일일이 협의하지 않고도 개발자 본인이 담당한 서비스 스키마를 변경가능. 
 	- 런타임에 서비스는 서로 완전히 분리되어 있음 
	- 즉, 다른 서비스가 DB 락을 획득해 내 서비스를 블로킹(blocking, 차단)하는 일 따위는 일어나지 않음.
 

 ### 1.4.4 FTGO 마이크로서비스 아키텍처
 	FTGO 애플리케이션을 마이크로서비스 아키텍처로 전환하는 과정으로 Y축 확장을 적용하면 어떻게 되는지 보자.

 <center> <img src="/fig1-7.jpg" width="800" height="500"> </center>
   [그림 1-7] y축확장을 적용한 FTGO 애플리케이션 
  

	- 기능별로 분해된 여러 프런트엔드/백엔드 서비스가 애플리케이션을 이룸  
	- 이 모습으로 런타임에 X축/Z축 확장을 하면 서비스마다 인스턴스가 여럿 존재할 것임.
	- 프런트엔드 서비스는 API 게이트웨이(8장)와 음식점 웹 UI 같은 것들이 존재  
	- 퍼사드(façade, 관문) 역할을 하는 API 게이트웨이는 소비자, 배달원의 모바일 앱이 접속하는 REST API를 제공 
	- 음식점 웹 UI에는 음식점 주인이 메뉴를 관리하거나 주문을 처리하는 웹 인터페이스가 구현됨
	- FTGO 애플리케이션의 비즈니스 로직은 REST API와 자체 프라이빗(private, 비공개) 데이터 저장소를 소유한 다양한 백엔드 서비스로 구성
		• 주문 서비스(Order Service): 주문을 관리
 		• 배달 서비스(Delivery Service): 음식점에서 소비자에 이르기까지 주문 배달관리
 		• 음식점 서비스(Restaurant Service): 음식점 관련 정보를 관리
		• 주방 서비스(Kitchen Service): 주문한 음식을 준비하는 과정을 관리
 		• 회계 서비스(Accounting Service): 과금/지불을 처리
 		 ==> 각 서비스를 독립적으로 개발, 테스트, 배포, 확장가능
 		 ==> 개발자가 타 서비스의 API를 우회하거나 그 내부 요소에 직접 접근할 수 없기 때문에 모듈성유지차원에서도 적합한 아키텍처. 


	
 ### 1.4.5 마이크로서비스 아키텍처와 SOA 차이점 
 
 <center> <img src="/table1-1.PNG" width="600" height="300"> </center>
  [표 1-1] 마이크로서비스 아키텍처와 SOA 차이점 
 
#### 1. 사용하는 기술 스택이 다름
	- SOA 애플리케이션은 SOAP 및 WS* 표준 등 무거운 기술을 주로 쓰고,
	- 서비스를 통합하는 비즈니스와 메시지 처리 로직이 포함된 ESB라는 스마트 파이프(smart pipe)를 활용. 
 	- 마이크로서비스 애플리케이션은 대개 가벼운 오픈 소스 기술을 사용하며, 
 	- 메시지 브로커(message broker, 중계기)나 REST 또는 gRPC처럼 가벼운 프로토콜 위주의 덤 파이프(dumb pipe)를 통해 서비스 간 통신함.


#### 2. 데이터 처리 방식
 	- SOA는 보통 전역 데이터 모델링을 하고 DB도 공유하지만 마이크로서비스는 앞서 말했듯이 각자 자체 DB, 자체 도메인 모델을 소유

#### 3. 서비스의 크기
 	- SOA는 대부분 크고 복잡한 모놀리식 애플리케이션을 통합하는 용도로 사용
 	- 마이크로서비스라고 해서 항상 작은 것은 아니지만, 대체로 SOA보다는 훨씬 규모가 작은 수십~수백 개의 서비스로 구성됨
 


<br/><br/><br/>

## 1.5 마이크로서비스 아키텍처 장단점

### 1.5.1 장점
 	- 크고 복잡한 애플리케이션을 지속적으로 전달/배포할 수 있습니다.
 	- 서비스 규모가 작아 관리하기 쉽습니다.
 	- 서비스를 독립적으로 배포/확장할 수 있습니다.
 	-  마이크로서비스 아키텍처 덕분에 팀이 자율적으로 움직입니다.
 	-  결함 격리가 잘됩니다.
 	- 새로운 기술을 실험하고 도입하기 쉽습니다.
 
### 1.5.2 단점
 	- 딱 맞는 서비스를 찾기가 쉽지 않습니다.
 	- 분산 시스템은 너무 복잡해서 개발, 테스트, 배포가 어렵습니다.
 	- 여러 서비스에 걸친 기능을 배포할 때에는 잘 조정해야 합니다.
 	- 마이크로서비스 아키텍처 도입 시점을 결정하기가 어렵습니다.
 
<br/><br/><br/>

 ## 1.6 마이크로서비스 아키텍처 패턴 언어

 ### 1.6.1 마이크로서비스 아키텍처도 만병통치약은 아니다
 	- 어떤 애플리케이션에 적합할지는 여러 요인에 따라 달라지므로 
 	- 무턱대고 마이크로서비스 아키텍처만 쓰라는 말도, 
 	- 그렇다고 마이크로서비스 아키텍처를 절대 쓰지 말라는 말도 그릇된 조언임


 ### 1.6.2 패턴 및 패턴 언어
	- 패턴은 특정한 상황에서 발생한 문제에 대한 재사용 가능한 해법
 	- 패턴 언어는 특정 영역 내부에서 문제를 해결하는 연관된 패턴의 집합
  	
	- (예) 다양한 마이너스 통장(overdraft) 정책을 지원해야 하는 뱅킹 애플리케이션
 	- 계좌 잔고 한도 및 초과 인출된 계좌에 부과되는 수수료는 은행 정책마다 다름  전략 패턴(Strategy pattern)으로 해결
 	- 전략 패턴에 따르면 이 문제의 솔루션은 다음 세 가지로 구성됩니다.
 	   *-  초과 인출 알고리즘을 캡슐화한 전략 인터페이스 Overdraft
 	   *-  하나 이상의 전략 구상 클래스(concrete class)(각각 특정 맥락(context)을 표현함)
 	   *- 알고리즘을 사용하는 Account 클래스

	- 패턴은 자신이 적용되는 맥락을 반드시 기술해야 한다.
 	- 상용 패턴의 구조는 강제 조항(forces), 결과 맥락(resulting context), 연관 패턴(related patterns) 으로 구성됩니다.

  #### 1. 강제 조항: 문제 해결을 위해 반드시 처리해야 할 이슈
  	• 상충하는 강제 조항도 있기 때문에 모든 조항을 전부 충족할 수는 없고, 
	• 어느 조항이 더 중요한지는 맥락에 따라 다르므로 우선순위를 정해야 합니다. 
  	• (예) 코드는 이해하기 쉬워야 하는 동시에 성능도 우수해야 합니다. 
	• 리액티브 스타일로 작성한 코드는 동기 코드보다 성능은 우수할지 모르지만 개발자가 이해하기는 상대적으로 어렵습니다. 
	• 강제 조항을 명시적으로 나열하면 어느 이슈를 해결해야 할지 명확해집니다.


  #### 2. 결과 맥락: 패턴을 적용한 결과를 다음 세 부분으로 기술하는 영역
	• 장점: (해결된 강제 조항 등) 패턴의 좋은 점
 	• 단점: (미해결 강제 조항 등) 패턴의 나쁜 점
  	• 이슈: 패턴 적용 시 발생한 새로운 문제점
 	• 결과 맥락은 솔루션을 편견에 치우지지 않은, 좀 더 완전한 시야로 바라보게 함==>  더 나은 설계 결정 가능.


#### 3. 연관 패턴: 다섯 가지 관계 유형
 	한 패턴과 다른 패턴의 관계를 기술하는 영역으로, 패턴 관계는 다섯 가지 종류가 있습니다.
 	1. 선행자(predecessor): 이 패턴을 필요하게 만든 선행 패턴. 
		가령 마이크로서비스 아키텍처 패턴은 모놀리식 아키텍처 패턴을 제외한 나머지 패턴들의 선행자입니다.
 	2. 후행자(successor): 이 패턴으로 야기된 이슈를 해결하는 패턴. 
		가령 마이크로서비스 아키텍처 패턴을 적용하려면 서비스 디스커버리 패턴, 
		회로 차단기 패턴 등 후행자 패턴도 함께 적용해야 합니다.
  	3. 대안(alternative): 이 패턴의 대체 솔루션을 제공하는 패턴. 
		가령 모놀리식 아키텍처 패턴과 마이크로서비스 아키텍처 패턴은 서로를 대신할 수 있는 애플리케이션 아키텍처링 수단입니다. 
		둘 중 하나를 선택하면 됩니다.
  	4. 일반화(generalization): 문제를 해결하는 일반적인 솔루션에 해당하는 패턴
  	5. 세분화(specialization): 특정 패턴을 더 세부적으로 나타낸 형태




 ### 1.6.3 마이크로서비스 아키텍처 패턴 언어 개요
	- 마이크로서비스 아키텍처 패턴 언어 : 전체 애플리케이션을 마이크로서비스 아키텍처로 구성할 때 유용한 패턴의 모음집(그림 1-10). 
	- 패턴 언어는 여러 그룹의 패턴으로 구성된다
	- 왼쪽은 모놀리식 아키텍처 패턴과 마이크로서비스 아키텍처 패턴이 위치한 애플리케이션 아키텍처 패턴 그룹이고. 
	- 나머지는 마이크로서비스 아키텍처 패턴 사용 시 각종 이슈를 해결하는 솔루션 패턴을 모아 놓은 패턴 그룹이다.

<center> <img src="/fig1-10.jpg" width="800" height="500"> </center>
[그림 1-10] 마이크로서비스 아키텍처 패턴 언어를 고수준에서 바라본 그림.  
왼쪽은 애플리케이션 아키텍처 패턴(모놀리식/마이크로서비스 아키텍처), 나머지 그룹은 마이크로서비스 아키텍처 패턴의 문제를 해결하는 패턴들 임

	- 패턴은 다시 세 계층으로 분류됩니다.
		• 인프라 패턴(infrastructure pattern): 주로 개발 영역 밖의 인프라 문제 해결
		• 애플리케이션 인프라(application infrastructure): 개발에도 영향을 미치는 인프라 문제 해결
		• 애플리케이션 패턴(application pattern): 개발자가 맞닥뜨리는 문제 해결

	- 패턴은 해결하려는 문제의 종류별로 묶을 수 있음.
		•애플리케이션을 여러 서비스로 분해하는 패턴
<center> <img src="/fig1-11.jpg" width="500" height="350"> </center>
		[그림 1-11] 분해 패턴은 비즈니스 능력에 따라 서비스를 구성하는 방법과 DDD 하위 도메인(sub-domain)에 따라 서비스를 구성하는 방법 두가지 다. 
	
		•통신패턴
<center> <img src="/fig1-12.jpg" width="800" height="500"> </center>
		[그림 1-12] 다섯 통신 패턴 그룹
		
		
		•트랜잭션 관리를 위한 데이터 일관성 패턴
<center> <img src="/fig1-13.jpg" width="500" height="350"> </center>
		[그림 1-13] 서비스마다 자체 DB를 갖고 있으므로 사가 패턴에 따라 서비스 간 데이터 일관성을 유지해야 한다
		
		
		•데이터 쿼리패턴
		
<center> <img src="/fig1-14.jpg" width="500" height="350"> </center>
		[그림 1-14] 서비스마다 자체 DB를 갖고 있으므로 두 가지 쿼리 패턴 중 하나를 사용하여 여러 서비스에 흩어진 데이터를 조회한다
		
		
		•서비스 배포 패턴
		
<center> <img src="/fig1-15.jpg" width="800" height="500"> </center>
		 [그림 1-15] 마이크로서비스의 다양한 배포 패턴. 기존에는 흔히 서비스를 언어에 특정한 패키징 포맷으로 묶어 배포했다. 
		 요즘은 크게 두 가지 방식으로 서비스를 배포한다. 
		 첫째, VM이나 컨테이너에 배포한다. 
		 둘째, 서버리스(서버가 없는) 방식이다. 그냥 서비스 코드만 업로드하면 서버리스 플랫폼이 코드를 알아서 실행한다.
		 서비스 배포 플랫폼은 서비스 배포/관리를 자동화한, 자체 서비스 플랫폼을 사용해야 한다
		
		•관측성 패턴: 애플리케이션 동작 파악 		
		 ' 헬스 체크(health check) API: 서비스 헬스(가동 상태)를 반환하는 끝점(endpoint, 엔드포인트)을 표출(expose)합니다.
		 ' 로그 수집(log aggregation): 서비스 내역을 기록하고 중앙 로깅 서버에 로그를 출력하여 검색/경고 기능을 제공합니다.
		 ' 분산 추적(distributed tracing): 각 외부 요청마다 ID를 부여하여 서비스를 통과하는 과정을 추적합니다.
		 ' 예외 추적(exception tracking): 예외가 발생하면 예외 추적 서비스에 보고합니다. 
		 ' 애플리케이션 지표(application metrics): 카운터, 게이지 등의 지표(metric, 메트릭)를 측정하여 지표 서버에 표출합니다.
		 ' 감사 로깅(audit logging): 사용자가 한 일을 기록합니다.

		
		•서비스테스트 자동화 패턴
		  ' 컨슈머 주도 계약 테스트(consumer-driven contract test): 클라이언트가 의도한 대로 서비스가 동작하는지 확인합니다.
		  ' 컨슈머 쪽 계약 테스트(consumer-side contract test): 클라이언트와 서비스가 상호 통신 가능한지 확인합니다.
		  ' 서비스 컴포넌트 테스트(service component test): 서비스를 따로따로 테스트합니다.
		
		
		•횡단 관심사 처리 패턴
		
		•보안 패턴
		
		

<br/><br/><br/>

 ## 1.7 마이크로서비스 너머: 프로세스와 조직 
 	• 소프트웨어를 성공적으로 개발하려면 데브옵스 및 자율적인 소규모 팀으로 구성되어야 함.
 	• 마이크로서비스를 검토할 때 직원들이 느끼는 감정도 충분히 반영되어야 성공적인 전환이 가능함.


<br/><br/><br/>

 ## 1.8 마치며 
 	• 모놀리식 아키텍처 패턴은 애플리케이션을 하나의 배포 단위로 구성합니다.
 	• 마이크로서비스 아키텍처 패턴은 독립적으로 배포 가능하면서 자체 DB를 보유한 서비스들로 시스템을 분해합니다.
 	• 단순한 애플리케이션은 모놀리식 아키텍처가, 크고 복잡한 애플리케이션은 마이크로서비스 아키텍처가 더 적합한 선택입니다.
 	• 마이크로서비스 아키텍처를 채택하면 자율적인 소규모 팀들이 작업을 병행할 수 있어서 소프트웨어 개발 속도가 빠릅니다.
 	• 마이크로서비스 아키텍처는 만병통치약이 아닙니다. 복잡성을 비롯하여 중요한 단점도 있습니다.
 	• 마이크로서비스 아키텍처 패턴 언어는 마이크로서비스 아키텍처로 애플리케이션을 설계할 때 유용한 패턴들의 모음집입니다. 
	• 패턴 언어는 마이크로서비스 아키텍처 도입 여부 결정 시 유용하며, 마이크로서비스 아키텍처를 효과적으로 적용하는 충실한 안내자입니다.
 	• 소프트웨어 전달 속도를 높이려면 마이크로서비스 아키텍처만으로는 부족합니다. 
	• 소프트웨어를 성공적으로 개발하려면 데브옵스 및 자율적인 소규모 팀들이 있어야 합니다.
 	• 마이크로서비스를 검토할 때 인간적인 측면도 고려해야 합니다. 직원들이 느끼는 감정도 충분히 반영되어야 한다
